<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>BandApp Pro - Live Sync</title>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

  <style>
    :root { --bg: #000; --text: #eee; --accent: #ff9800; --edit: #2196F3; }
    body {
      font-family: sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      overflow: hidden;
      overscroll-behavior-x: none;
    }

    /* ==== USER PICKER ==== */
    #userOverlay {
      position: fixed;
      inset: 0;
      z-index: 5000;
      display: none;
      background: rgba(0,0,0,0.92);
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    #userModal {
      width: min(560px, 100%);
      background: #111;
      border: 1px solid #2a2a2a;
      border-radius: 14px;
      overflow: hidden;
    }
    #userModal header {
      padding: 14px 16px;
      border-bottom: 1px solid #2a2a2a;
      background: #161616;
    }
    #userModal header h3 {
      margin: 0;
      font-size: 14px;
      color: #fff;
    }
    #userModal .content { padding: 14px 16px; }
    #userModal .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .user-choice {
      border: 1px solid #333;
      background: #0b0b0b;
      border-radius: 12px;
      padding: 12px;
      cursor: pointer;
      text-align: center;
      font-weight: bold;
      color: #fff;
      user-select: none;
    }
    .user-choice:hover { background: #101010; }
    #userModal .actions {
      padding: 14px 16px;
      border-top: 1px solid #2a2a2a;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    #userBadge {
      position: fixed;
      top: 8px;
      right: 8px;
      z-index: 3000;
      background: rgba(20,20,20,0.9);
      border: 1px solid #333;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px;
      display: none;
      align-items: center;
      gap: 10px;
    }
    #userBadge b { color: #fff; }

    /* Bibliothèque */
    #library { height: 100vh; overflow-y: auto; display: block; -webkit-overflow-scrolling: touch; }
    .lib-header { padding: 20px; background: #1a1a1a; border-bottom: 2px solid var(--accent); display: flex; justify-content: space-between; align-items: center; position: sticky; top:0; z-index: 5; }
    .song-item { padding: 20px; border-bottom: 1px solid #222; display: flex; justify-content: space-between; font-size: 1.1em; cursor: pointer; }

    /* Lecteur */
    #viewer-container { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: var(--bg); z-index: 10; }
    nav { display: flex; background: #1a1a1a; min-height: 60px; align-items: center; padding: 0 10px; gap: 8px; border-bottom: 1px solid #333; flex-wrap: wrap; }
    .controls-group { display:flex; align-items:center; gap:5px; background:#222; padding:5px; border-radius:8px; }

    /* Bandeau update */
    #updateBanner {
      position: sticky;
      top: 0;
      z-index: 999;
      display: none;
      background: #222;
      border-bottom: 1px solid #444;
      padding: 10px 12px;
      font-size: 14px;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    #updateBanner .msg { color: #ddd; }
    #updateBanner .btn-small {
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 12px;
    }

    /* Panneau notes */
    #notesPanel {
      display: none;
      background: #111;
      border-bottom: 1px solid #333;
      padding: 12px;
    }
    #notesTextarea {
      width: 100%;
      min-height: 120px;
      background: #000;
      color: #0f0;
      border: 1px solid #333;
      padding: 10px;
      font-family: monospace;
      resize: vertical;
      box-sizing: border-box;
    }

    #viewer {
      height: calc(100vh - 65px);
      overflow-y: scroll;
      padding: 25px;
      font-family: 'Courier New', Courier, monospace;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: auto !important;
      touch-action: pan-y;
    }

    /* Rendu ChordPro (aligné) */
    .block { margin-bottom: 26px; }
    .chordline, .lyricline {
      white-space: pre-wrap;      /* ✅ reste dans l’écran */
      word-break: break-word;     /* ✅ casse si mot trop long */
      overflow-wrap: anywhere;    /* ✅ évite débordement */
      line-height: 1.6;
      margin: 0;
    }
    .chordline { color: var(--accent); font-weight: bold; }

    /* Éditeur */
    #editor-container { display: none; position: fixed; top: 60px; left: 0; width: 100vw; height: calc(100vh - 60px); background: #111; z-index: 20; }
    #editor-textarea { width: 100%; height: 80%; background: #000; color: #2196F3; border: none; font-family: monospace; font-size: 16px; padding: 20px; box-sizing: border-box; }
    .editor-footer { height: 20%; display: flex; justify-content: center; align-items: center; gap: 20px; background: #1a1a1a; }

    .btn { cursor: pointer; padding: 10px 14px; border: 2px solid var(--accent); border-radius: 6px; color: var(--accent); background: none; font-size: 13px; font-weight: bold; }
    .btn-blue { border-color: var(--edit); color: var(--edit); }
    .leader-mode { background: var(--accent) !important; color: #000 !important; }
    .active-btn { background: #444; color: #fff; }

    /* Modal choix (simple) */
    #editChoiceBackdrop {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 2000;
      background: rgba(0,0,0,0.75);
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    #editChoiceModal {
      width: min(560px, 100%);
      background: #121212;
      border: 1px solid #2a2a2a;
      border-radius: 14px;
      overflow: hidden;
    }
    #editChoiceModal header { padding: 14px 16px; border-bottom: 1px solid #2a2a2a; background: #161616; }
    #editChoiceModal header h3 { margin: 0; font-size: 14px; color: #fff; }
    #editChoiceModal .content { padding: 14px 16px; }
    #editChoiceModal .actions { padding: 14px 16px; border-top: 1px solid #2a2a2a; display: flex; justify-content: flex-end; }

    .choice {
      border: 1px solid #333;
      background: #0b0b0b;
      border-radius: 12px;
      padding: 12px;
      cursor: pointer;
    }
    .choice:hover { background: #101010; }
    .choice b { color: #fff; display:block; margin-bottom: 6px; }
    .choice .small { color:#aaa; font-size:12px; display:block; }
  </style>
</head>

<body>
  <!-- Badge user (toujours visible) -->
  <div id="userBadge">
    <span>Utilisateur :</span>
    <b id="userNameLabel">—</b>
    <button class="btn" style="padding:6px 10px; font-size:12px;" onclick="openUserPicker(true)">Changer</button>
  </div>

  <!-- Overlay choix utilisateur -->
  <div id="userOverlay">
    <div id="userModal">
      <header><h3>Choisir l’utilisateur</h3></header>
      <div class="content">
        <div class="grid" id="userGrid"></div>
      </div>
      <div class="actions">
        <button class="btn" style="border-color:#777;color:#777;" onclick="addUser()">+ Ajouter</button>
        <button class="btn btn-blue" onclick="closeUserPicker()">OK</button>
      </div>
    </div>
  </div>

  <!-- Modal choix édition -->
  <div id="editChoiceBackdrop">
    <div id="editChoiceModal">
      <header><h3>Type de modification</h3></header>
      <div class="content">
        <div class="choice" onclick="chooseEditMode('personal')">
          <b>Modification personnelle</b>
          <span class="small">Sauvegardée pour <b>cet utilisateur</b> uniquement (ne modifie pas le fichier partagé).</span>
        </div>
        <div style="height:10px"></div>
        <div class="choice" onclick="chooseEditMode('global')">
          <b>Modification pour tout le monde</b>
          <span class="small">Modifie le fichier partagé (PIN demandé immédiatement).</span>
        </div>
      </div>
      <div class="actions">
        <button class="btn" onclick="closeEditChoice()" style="border-color:#777;color:#777;">ANNULER</button>
      </div>
    </div>
  </div>

  <div id="library">
    <div class="lib-header">
      <h2 style="margin:0;">Répertoire</h2>
      <button class="btn" id="libLeaderBtn" onclick="toggleLeader()">Mode Solo</button>
    </div>
    <div id="songList"></div>
  </div>

  <div id="viewer-container">
    <nav>
      <button class="btn" onclick="closeViewer()">⬅</button>

      <div class="controls-group">
        <button class="btn" id="playBtn" onclick="toggleAutoScroll(true)">▶</button>
        <input type="range" id="scrollSpeed" min="1" max="95" value="50">
      </div>

      <div class="controls-group">
        <button class="btn" onclick="updateFontSize(-2)">A-</button>
        <button class="btn" onclick="updateFontSize(2)">A+</button>
      </div>

      <div class="controls-group">
        <button class="btn" onclick="updateTranspose(-1)">-</button>
        <span id="transposeVal" style="min-width:20px; text-align:center">0</span>
        <button class="btn" onclick="updateTranspose(1)">+</button>
      </div>

      <button class="btn" onclick="toggleNotes()">NOTES</button>
      <button class="btn btn-blue" onclick="openEditor()">ÉDITER</button>
      <button class="btn" id="navLeaderBtn" onclick="toggleLeader()">Solo</button>
    </nav>

    <div id="updateBanner">
      <div class="msg">Une mise à jour de cette chanson est disponible.</div>
      <div style="display:flex; gap:8px;">
        <button class="btn btn-small" onclick="dismissUpdate()">PLUS TARD</button>
        <button class="btn btn-blue btn-small" onclick="reloadCurrentSong()">RECHARGER</button>
      </div>
    </div>

    <!-- ✅ Notes personnelles -->
    <div id="notesPanel">
      <textarea id="notesTextarea" placeholder="Tes annotations personnelles..."></textarea>
    </div>

    <div id="viewer">
      <div id="songContent"></div>
      <div style="height: 85vh;"></div>
    </div>
  </div>

  <div id="editor-container">
    <textarea id="editor-textarea" spellcheck="false"></textarea>
    <div class="editor-footer">
      <button class="btn" onclick="closeEditor()" style="border-color: #ff5252; color: #ff5252;">ANNULER</button>
      <button class="btn btn-blue" onclick="saveEditor()">ENREGISTRER</button>
    </div>
  </div>

  <script>
    const socket = io();

    let isLeader = false, allSongs = [], currentIndex = -1;
    let currentRaw = "", currentFileName = "", fontSize = 26, transposeValue = 0;

    let isRemoteScrolling = false;

    // Auto-scroll (RAF + carry)
    let isScrolling = false;
    let rafId = null;
    let lastRafTime = 0;
    let scrollCarry = 0;

    const viewerElement = document.getElementById('viewer');
    // --- SWIPE (précédent/suivant) ---
    let touchStartX = 0, touchStartY = 0;
    const SWIPE_MIN_X = 110;     // distance mini en px
    const SWIPE_RATIO = 1.4;     // dx doit être bien > dy

    const songContentEl = document.getElementById('songContent');
    const speedInput = document.getElementById('scrollSpeed');

    // Update banner
    const updateBanner = document.getElementById('updateBanner');

    // Notes
    const notesPanel = document.getElementById('notesPanel');
    const notesTextarea = document.getElementById('notesTextarea');

    // ---- EDIT MODE + PIN CACHE ----
    let editMode = null;        // 'personal' | 'global'
    let globalPinCache = "";    // PIN saisi au moment du choix global

    // ---- USERS (Nemo, Estelle, etc.) ----
    const DEFAULT_USERS = ["Nemo","Estelle","Gillou","Bubu","Christian","Christophe"];
    let currentUser = "";
    let users = [];

    const userOverlay = document.getElementById('userOverlay');
    const userGrid = document.getElementById('userGrid');
    const userBadge = document.getElementById('userBadge');
    const userNameLabel = document.getElementById('userNameLabel');

    function loadUsersList() {
      const savedList = localStorage.getItem('bandapp_users');
      if (savedList) {
        try {
          const parsed = JSON.parse(savedList);
          if (Array.isArray(parsed) && parsed.length) return parsed;
        } catch {}
      }
      return [...DEFAULT_USERS];
    }

    function saveUsersList() {
      localStorage.setItem('bandapp_users', JSON.stringify(users));
    }

    function renderUserGrid() {
      userGrid.innerHTML = "";
      users.forEach(name => {
        const div = document.createElement('div');
        div.className = 'user-choice';
        div.textContent = name;
        div.onclick = () => setCurrentUser(name);
        userGrid.appendChild(div);
      });
    }

    function setCurrentUser(name) {
      currentUser = String(name || "").trim();
      if (!currentUser) return;
      localStorage.setItem('bandapp_currentUser', currentUser);
      userNameLabel.textContent = currentUser;
      userBadge.style.display = 'flex';

      // quand on change d’utilisateur, on recharge les notes du morceau courant (si ouvert)
      if (currentFileName) loadNotes();
    }

    function openUserPicker(force) {
      // si déjà défini et pas forcé, on ne montre pas
      const saved = localStorage.getItem('bandapp_currentUser') || "";
      if (!force && saved) return;

      userOverlay.style.display = 'flex';
      renderUserGrid();
    }

    function closeUserPicker() {
      userOverlay.style.display = 'none';
      // si aucun user choisi, on en impose un (le 1er)
      if (!currentUser && users.length) setCurrentUser(users[0]);
    }

    function addUser() {
      const name = prompt("Nom du nouvel utilisateur ?") || "";
      const clean = String(name).trim();
      if (!clean) return;
      if (users.some(u => u.toLowerCase() === clean.toLowerCase())) return;

      users.push(clean);
      users.sort((a,b)=>a.localeCompare(b, 'fr', { sensitivity:'base' }));
      saveUsersList();
      renderUserGrid();
    }

    function initUsers() {
      users = loadUsersList();
      saveUsersList();

      const saved = localStorage.getItem('bandapp_currentUser') || "";
      if (saved) {
        setCurrentUser(saved);
        // pas besoin d’ouvrir le picker
      } else {
        openUserPicker(true);
      }
    }

    // Connexion témoin
    socket.on('connect', () => { document.getElementById('navLeaderBtn').style.borderColor = "#4CAF50"; });
    socket.on('disconnect', () => { document.getElementById('navLeaderBtn').style.borderColor = "#f44336"; });

    async function fetchSongs() {
      const res = await fetch('/list-songs');
      allSongs = (await res.json()).sort();
      document.getElementById('songList').innerHTML = allSongs.map((s, idx) => `
        <div class="song-item" onclick="openSong(${idx})">
          <b>${s.replace('.pro','').replace('.cho','')}</b><span>❯</span>
        </div>`).join('');
    }

    function toggleLeader() {
      isLeader = !isLeader;
      const btns = [document.getElementById('libLeaderBtn'), document.getElementById('navLeaderBtn')];
      btns.forEach(btn => {
        btn.classList.toggle('leader-mode', isLeader);
        btn.innerText = isLeader ? "Mode Leader" : "Mode Solo";
      });
      if (!isLeader) stopAutoScroll();
    }

    function openSong(idx) {
      if (idx < 0 || idx >= allSongs.length) return;
      currentIndex = idx;
      currentFileName = allSongs[idx];

      updateBanner.style.display = 'none';
      notesPanel.style.display = 'none'; // on ferme les notes en changeant de morceau

      document.getElementById('library').style.display = 'none';
      document.getElementById('viewer-container').style.display = 'block';

      if (isLeader) socket.emit('change-song', currentFileName);

      loadSong(currentFileName);
      setTimeout(loadNotes, 10);
    }

    async function loadSong(f) {
      const res = await fetch('/partitions/' + f);
      currentRaw = await res.text();
      transposeValue = 0;
      document.getElementById('transposeVal').innerText = "0";
      renderChordPro();
      viewerElement.scrollTop = 0;
      updateBanner.style.display = 'none';
    }

    // --- SONG UPDATED ---
    function normName(s) {
      return String(s || '').trim().toLowerCase().replace(/\s+/g, ' ');
    }
    socket.on('song-updated', ({ fileName }) => {
      const viewerOpen = document.getElementById('viewer-container').style.display === 'block';
      if (!viewerOpen) return;
      const sameSong = normName(fileName) === normName(currentFileName);
      if (sameSong) updateBanner.style.display = 'flex';
    });

    function dismissUpdate() { updateBanner.style.display = 'none'; }
    function reloadCurrentSong() {
      stopAutoScroll();
      loadSong(currentFileName);
    }

    // --- NOTES PERSONNELLES (PAR UTILISATEUR) ---
    function notesKey(fileName) {
      const u = currentUser || "unknown";
      return "notes:" + u + ":" + fileName;
    }

    function loadNotes() {
      if (!currentFileName) return;
      const val = localStorage.getItem(notesKey(currentFileName)) || "";
      notesTextarea.value = val;
    }

    function saveNotes() {
      if (!currentFileName) return;
      localStorage.setItem(notesKey(currentFileName), notesTextarea.value || "");
    }

    function toggleNotes() {
      const visible = notesPanel.style.display === "block";
      notesPanel.style.display = visible ? "none" : "block";
      if (!visible) loadNotes();
    }

    notesTextarea.addEventListener('input', saveNotes);

    // --- SYNCHRO SCROLL ---
    let lastEmitAt = 0;
    let lastEmitPos = -1;

    viewerElement.addEventListener('scroll', () => {
      if (!isLeader || isRemoteScrolling) return;

      const max = viewerElement.scrollHeight - viewerElement.clientHeight;
      const pos = max > 0 ? (viewerElement.scrollTop / max) : 0;

      const now = Date.now();
      if (now - lastEmitAt < 80 && Math.abs(pos - lastEmitPos) < 0.003) return;

      lastEmitAt = now;
      lastEmitPos = pos;
      socket.emit('scroll-sync', pos);
    });

    function isEditorOpen() {
      return document.getElementById('editor-container').style.display === 'block';
    }
    function isViewerOpen() {
      return document.getElementById('viewer-container').style.display === 'block';
    }

    viewerElement.addEventListener('touchstart', (e) => {
      if (!isViewerOpen() || isEditorOpen()) return;

      // si on commence le geste dans la zone notes (textarea), on ne swipe pas
      if (e.target && e.target.id === 'notesTextarea') return;

      const t = e.changedTouches[0];
      touchStartX = t.screenX;
      touchStartY = t.screenY;
    }, { passive: true });

    viewerElement.addEventListener('touchend', (e) => {
      if (!isViewerOpen() || isEditorOpen()) return;
      if (e.target && e.target.id === 'notesTextarea') return;

      const t = e.changedTouches[0];
      const dx = t.screenX - touchStartX;
      const dy = t.screenY - touchStartY;

      if (Math.abs(dx) < SWIPE_MIN_X) return;
      if (Math.abs(dx) < Math.abs(dy) * SWIPE_RATIO) return;

      if (dx > 0 && currentIndex > 0) openSong(currentIndex - 1);
      else if (dx < 0 && currentIndex < allSongs.length - 1) openSong(currentIndex + 1);
    }, { passive: true });

    socket.on('apply-scroll', p => {
      if (!isLeader) {
        isRemoteScrolling = true;
        const max = viewerElement.scrollHeight - viewerElement.clientHeight;
        viewerElement.scrollTop = (Number(p) || 0) * (max > 0 ? max : 0);
        setTimeout(() => { isRemoteScrolling = false; }, 50);
      }
    });

    // --- AUTO-SCROLL ---
    function sliderToPxPerSecond(value) {
      const v = Number(value) || 50;
      const delayMs = Math.max(10, 105 - v);
      return 1000 / delayMs;
    }

    function autoScrollLoop(t) {
      if (!isScrolling) return;

      if (!lastRafTime) lastRafTime = t;
      const dt = t - lastRafTime;
      lastRafTime = t;

      const pxPerSec = sliderToPxPerSecond(speedInput.value);
      const deltaPx = (dt / 1000) * pxPerSec;

      scrollCarry += deltaPx;
      const step = Math.floor(scrollCarry);

      if (step >= 1) {
        viewerElement.scrollTop += step;
        scrollCarry -= step;
      }

      rafId = requestAnimationFrame(autoScrollLoop);
    }

    function startAutoScroll() {
      if (isScrolling) return;
      isScrolling = true;
      document.getElementById('playBtn').innerText = "⏸";
      document.getElementById('playBtn').classList.add('active-btn');
      lastRafTime = 0;
      scrollCarry = 0;
      rafId = requestAnimationFrame(autoScrollLoop);
    }

    function stopAutoScroll() {
      if (!isScrolling) return;
      isScrolling = false;
      document.getElementById('playBtn').innerText = "▶";
      document.getElementById('playBtn').classList.remove('active-btn');
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      lastRafTime = 0;
      scrollCarry = 0;
    }

    function toggleAutoScroll(emitSync) {
      if (isScrolling) stopAutoScroll();
      else startAutoScroll();

      if (isLeader && emitSync) {
        socket.emit('sync-autoscroll', { active: isScrolling, speed: speedInput.value });
      }
    }

    socket.on('apply-autoscroll', d => {
      if (!isLeader) {
        speedInput.value = d.speed;
        const wantActive = !!d.active;
        if (wantActive && !isScrolling) startAutoScroll();
        if (!wantActive && isScrolling) stopAutoScroll();
      }
    });

    // --- RENDU / POLICES / TRANSPOSITION ---
    function updateFontSize(delta) { fontSize += delta; renderChordPro(); }
    function updateTranspose(dir) {
      transposeValue += dir;
      document.getElementById('transposeVal').innerText = (transposeValue > 0 ? '+' : '') + transposeValue;
      renderChordPro();
    }

    const scale = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const scaleLat = ['Do','Do#','Ré','Ré#','Mi','Fa','Fa#','Sol','Sol#','La','La#','Si'];

    function normalizeNote(note) {
      return note
        .replace('Bb','A#')
        .replace('Db','C#')
        .replace('Eb','D#')
        .replace('Gb','F#')
        .replace('Ab','G#');
    }

    function transChord(chord, steps) {
      return chord.replace(/([A-G][#b]?)/g, (match) => {
        const n = normalizeNote(match);
        const idx = scale.indexOf(n);
        if (idx === -1) return match;
        let newIdx = (idx + steps) % 12;
        if (newIdx < 0) newIdx += 12;
        return scaleLat[newIdx];
      });
    }

    function parseChordProLine(line) {
      let chordLine = '';
      let lyricLine = '';

      let i = 0;
      while (i < line.length) {
        const ch = line[i];

        if (ch === '[') {
          const end = line.indexOf(']', i);
          if (end !== -1) {
            const chordRaw = line.slice(i + 1, end);
            const chord = transChord(chordRaw, transposeValue);

            const pos = lyricLine.length;
            if (chordLine.length < pos) chordLine += ' '.repeat(pos - chordLine.length);

            chordLine = chordLine.slice(0, pos) + chord + chordLine.slice(pos + chord.length);

            i = end + 1;
            continue;
          }
        }

        lyricLine += ch;
        chordLine += (ch === '\t') ? '\t' : ' ';
        i++;
      }

      if (chordLine.length < lyricLine.length) chordLine += ' '.repeat(lyricLine.length - chordLine.length);
      return { chordLine, lyricLine };
    }

    function clearSongContent() { songContentEl.replaceChildren(); }

    function addCenteredTitle(text, level) {
      const el = document.createElement(level === 1 ? 'h1' : 'h2');
      el.style.textAlign = 'center';
      if (level === 2) el.style.color = '#888';
      el.textContent = text;
      songContentEl.appendChild(el);
    }

    function addChordBlock(chordLine, lyricLine) {
      const block = document.createElement('div');
      block.className = 'block';
      block.style.fontSize = fontSize + 'px';

      const preChord = document.createElement('pre');
      preChord.className = 'chordline';
      preChord.textContent = chordLine;

      const preLyric = document.createElement('pre');
      preLyric.className = 'lyricline';
      preLyric.textContent = lyricLine;

      if (chordLine.trim().length > 0) block.appendChild(preChord);
      block.appendChild(preLyric);

      songContentEl.appendChild(block);
    }

    function renderChordPro() {
      clearSongContent();

      const lines = currentRaw.split('\n');
      for (const line of lines) {
        const t = line.match(/\{t:(.*?)\}/);
        if (t) { addCenteredTitle(t[1], 1); continue; }

        const st = line.match(/\{st:(.*?)\}/);
        if (st) { addCenteredTitle(st[1], 2); continue; }

        const { chordLine, lyricLine } = parseChordProLine(line);
        addChordBlock(chordLine, lyricLine);
      }
    }

    // --- SOCKETS ---
    socket.on('load-song', f => {
      if (!isLeader) {
        const idx = allSongs.indexOf(f);
        if (idx !== -1) openSong(idx);
      }
    });

    // --- EDIT UI ---
    function openEditChoice() {
      document.getElementById('editChoiceBackdrop').style.display = 'flex';
    }
    function closeEditChoice() {
      document.getElementById('editChoiceBackdrop').style.display = 'none';
    }

    function openEditor() {
      stopAutoScroll();
      openEditChoice();
    }

    // Perso : partition perso complète, stockée localement (PAR UTILISATEUR)
    function personalSongKey(fileName) {
      const u = currentUser || "unknown";
      return `personalSong:${u}:${fileName}`;
    }
    function getPersonalSong(fileName) { return localStorage.getItem(personalSongKey(fileName)) || ""; }
    function setPersonalSong(fileName, content) { localStorage.setItem(personalSongKey(fileName), content || ""); }

    // ✅ PIN demandé au moment du choix "global"
    async function chooseEditMode(mode) {
      editMode = mode;
      closeEditChoice();

      if (mode === 'personal') {
        globalPinCache = "";
        startEditorWithMode('personal');
        return;
      }

      let pin = prompt("PIN requis pour modifier pour tout le monde (ex: 1991)") || "";
      pin = String(pin).trim();

      if (!pin) {
        editMode = null;
        globalPinCache = "";
        return;
      }

      globalPinCache = pin;
      startEditorWithMode('global');
    }

    async function startEditorWithMode(mode) {
      if (mode === "personal") {
        const personal = getPersonalSong(currentFileName);
        document.getElementById('editor-textarea').value = personal || currentRaw;
      } else {
        const res = await fetch('/partitions/' + currentFileName);
        document.getElementById('editor-textarea').value = await res.text();
      }

      document.getElementById('editor-container').style.display = 'block';
    }

    function closeEditor() {
      document.getElementById('editor-container').style.display = 'none';
    }

    async function saveEditor() {
      const newContent = document.getElementById('editor-textarea').value;
      if (!currentFileName) return;

      // perso => pas de PIN
      if (editMode === "personal") {
        setPersonalSong(currentFileName, newContent);
        currentRaw = newContent;
        renderChordPro();
        closeEditor();
        return;
      }

      // global => on réutilise le PIN déjà saisi
      const pin = String(globalPinCache || "").trim();
      if (!pin) {
        alert("PIN manquant. Recommence et choisis 'pour tout le monde'.");
        return;
      }

      const res = await fetch('/save-song', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fileName: currentFileName, content: newContent, pin })
      });

      if (res.ok) {
        currentRaw = newContent;
        renderChordPro();
        closeEditor();

        // informer les autres (pas de PIN)
        if (isLeader) socket.emit('change-song', currentFileName);

      } else if (res.status === 403) {
        alert("PIN invalide");
        globalPinCache = "";
        editMode = null;
      } else {
        alert("Erreur d'enregistrement");
      }
    }

    function closeViewer() {
      stopAutoScroll();
      notesPanel.style.display = 'none';
      document.getElementById('library').style.display = 'block';
      document.getElementById('viewer-container').style.display = 'none';
    }

    // INIT
    initUsers();
    fetchSongs();
  </script>
</body>
</html>
